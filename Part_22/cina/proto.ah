// astnodes.c
public ASTnode *mkastnode(const int op, const ASTnode * left,
		const ASTnode * mid, const ASTnode * right);
public ASTnode *mkastleaf(const int op, const Type * ty, const bool rvalue,
		const Sym * sym, const int64 intval);
public void dumpAST(const ASTnode * n, int level);
public ASTnode *optAST(ASTnode * n);

// cgen.c
public int cgalloctemp(void);
public void cglabel(const int l);
public void cgjump(const int l);
public int cgalign(Type * ty, int offset);
public void cgstrlit(const int label, string val, const bool is_const);
public void cg_file_preamble(void);
public void cg_func_preamble(const Sym * func);
public void cg_func_postamble(const Type * ty);
public void cgglobsym(const Sym * sym, const bool make_zero);
public void cgglobsymval(const ASTnode * value, const int offset);
public void cgglobsymend(const Sym * sym);
public void cgloadboolean(const int t, const int val, const Type * ty);
public int cgloadlit(inout Litval value, const Type * ty);
public int cgadd(const int t1, const int t2, const Type * ty);
public int cgsub(const int t1, const int t2, const Type * ty);
public int cgmul(const int t1, const int t2, const Type * ty);
public int cgdiv(const int t1, const int t2, const Type * ty);
public int cgmod(const int t1, const int t2, const Type * ty);
public int cgnegate(const int t, const Type * ty);
public int cgcompare(const int op, const int t1, const int t2, const Type * ty);
public void cgjump_if_false(const int t1, const int label);
public int cgnot(const int t, const Type * ty);
public int cginvert(const int t, const Type * ty);
public int cgand(const int t1, const int t2, const Type * ty);
public int cgor(const int t1, const int t2, const Type * ty);
public int cgxor(const int t1, const int t2, const Type * ty);
public int cgshl(const int t1, const int t2, const Type * ty);
public int cgshr(const int t1, const int t2, const Type * ty);
public int cgloadvar(const Sym * sym);
public void cgrangecheck(const int t, const Type *ty, const int funcname);
public int cgstorvar(const int t, const Type * exprtype, const Sym * sym);
public int cgstore_element(const int basetemp, const int offset, const int exprtemp, const Type *ty);
public void cgaddlocal(const Type * ty, const Sym * sym, const int size, const bool makezero,
		const bool isarray);
public int cgcall(const Sym * sym, const int numargs, const int excepttemp, const int *arglist,
	   const Type ** typelist);
public void cgreturn(const int temp, const Type * ty);
public void cgabort(void);
public int cgloadglobstr(const int label);
public int cgaddress(const Sym * sym);
public int cgderef(const int t, const Type * ty);
public int cgstorderef(const int t1, const int t2, const Type * ty);
public int cgboundscheck(const int t1, const int counttemp, const int aryname, const int funcname);
public void cgmove(const int t1, const int t2, const Type * ty);
public void cg_vastart(const ASTnode *n);
public void cg_vaend(const ASTnode *n);
public int cg_vaarg(const ASTnode *n);
public int cgcast(int exprtemp, Type *ety, const Type *ty, const int funcname);
public int cg_getaaval(const int arytemp, const int keytemp, const Type *ty);
public void cg_setaaval(const int arytemp, const int keytemp, const int valtemp, const Type *ty);
public int cg_existsaaval(const int arytemp, const int keytemp);
public int cg_delaaval(const int arytemp, const int keytemp);
public int cg_strhash(const int keytemp);
public int cg_free_aarray(const Sym * sym);
public int cg_aaiterstart(const int arytemp);
public int cg_aanext(const int arytemp);
public int cg_funciterator(const ASTnode * n, const Breaklabel *this);
public void cg_stridxcheck(const int idxtemp, const int basetemp, const int funcname);
public int cg_arrayiterator(const ASTnode * n, const Breaklabel *this);
public int cg_copystruct(const int srctemp, const int desttemp, const int size);

// expr.c
public ASTnode *binop(const ASTnode * l, const ASTnode * r, const int op);
public ASTnode *unarop(const ASTnode * l, const int op);
public ASTnode *widen_expression(const ASTnode * e, const Type * ty);
public int cg_stringiterator(const ASTnode * n, const Breaklabel *this);
public ASTnode *get_ary_offset(const Sym *sym, ASTnode *e, const ASTnode *prevoffset, const int level);

// funcs.c
public bool add_function(const ASTnode * func,
			ASTnode * paramlist, const int visibility);
public void declare_function(const ASTnode * f, const int visibility);
public void gen_func_statement_block(const ASTnode * s);

// genast.c
public int genlabel(void);
public int genAST(const ASTnode * n);
public int genalign(const Type * ty, const int offset);
public void gen_file_preamble(void);
public void gen_func_preamble(const Sym * func);
public void gen_func_postamble(const Type * ty);
public int gen_assign(const int ltemp, const int rtemp, const ASTnode *n);
public ASTnode *check_bel(const Sym * sym, ASTnode * list, const int offset, const bool is_element, const int basetemp);

// lexer.c
public bool scan(inout Token t);
public string get_tokenstr(const int token);
public void dumptokens(void);
public void match(const int t, const bool getnext);
public void semi(void);
public void lbrace(void);
public void rbrace(void);
public void lparen(void);
public void rparen(void);
public void ident(void);
public void comma(void);

// misc.c
public void fatal(const string fmt, ...);
public void lfatal(const int line, const string fmt, ...);
public void cant_do(const ASTnode * n, const Type * t, const string msg);
public void *Malloc(const size_t size);
public void *Calloc(const size_t size);
public uint64 djb2hash(int8 * str);

// parser.c
public void input_file(void);

// strlits.c
public int add_strlit(const string name, const bool is_const);
public void gen_strlits(void);

// stmts.c
public ASTnode *assignment_statement(const ASTnode * v, ASTnode * e);
public ASTnode *declaration_statement(const ASTnode * s, ASTnode * e);

// syms.c
public void init_symtable(void);
public Sym *add_sym_to(inout Sym * head, string name, const int symtype, const Type * ty);
public Sym *add_symbol(string name, const int symtype, const Type * ty, const int visibility);
public Sym *find_symbol(string name);
public void new_scope(const Sym * func);
public ASTnode *end_scope(void);
public ASTnode *mkident(const ASTnode * n);
public int get_numelements(const Sym *sym, const int depth);
public int get_varsize(const Sym *sym);
public bool is_array(const Sym * sym);
public void gen_globsyms(void);
public void dumpsyms(void);

// types.c
public void init_typelist(void);
public Type *new_type(const int kind, const int size, const bool is_unsigned, const int ptr_depth, string name, const Type * base);
public Type *find_type(string typename, const int kind, const bool is_unsigned, const int ptr_depth);
public Type *pointer_to(const Type * ty);
public Type *value_at(const Type * ty);
public bool is_integer(const Type * ty);
public bool is_flonum(const Type * ty);
public bool is_numeric(const Type * ty);
public bool is_pointer(const Type * ty);
public bool is_struct(const Type * ty);
public string get_typename(const Type * ty);
public ASTnode *widen_type(ASTnode * node, const Type * ty, const int op);
public void add_type(const ASTnode * node);
public Type *parse_litval(inout Litval e);
public bool has_range(const Type *ty);
public Type *get_funcptr_type(const Sym *sym);
